"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const got = require("got");
// tslint:disable-next-line:no-var-requires
const FormData = require("form-data");
// tslint:disable-next-line:no-var-requires
const tunnel = require('tunnel');
const form = new FormData();
let responseData = Object;
/*CRUD operations PUT,POST,GET,DELETE and PATCH */
/**
 * This method is used to making http request
 * @param {string} url - form full url including path parameters if applicable
 * @param {object} headerOptions - pass header values
 * @param {string} HttpMethod - GET, POST , PUT, PATCH , DELETE etc , GET is default
 * @param {string} inputBody - json string
 * @param {boolean} formFlag - default false
 */
async function makeHttpRequest(url, headerOptions, HttpMethod, inputBody, formFlag) {
    if (headerOptions == null) {
        headerOptions = { Accept: "application/json" };
    }
    if (inputBody == null) {
        inputBody = "";
    }
    else if (formFlag) {
        inputBody = JSON.parse(inputBody);
    }
    if (HttpMethod == null) {
        HttpMethod = "GET"; //default GET method
    }
    if (formFlag == null) {
        formFlag = false;
    }
    try {
        responseData = await got(url, {
            headers: headerOptions,
            body: inputBody,
            form: formFlag,
            method: HttpMethod,
            retry: 1
        }); // Note: Using "any" for the type, since got has a number of variants for the options parameter.
        // It would be better to replace the "any" with a more specific type, if that can be determined.
    }
    catch (error) {
        const customError = JSON.parse(JSON.stringify(error));
        const message = {
            "message": error.message,
            "name": customError.name,
            "code": customError.code,
            "host": customError.host,
            "url": customError.url,
            "path": customError.path
        };
        throw JSON.stringify(message);
    }
    return responseData;
}
exports.makeHttpRequest = makeHttpRequest;
/*Sending Form-Data as requestBody for CRUD operations PUT,POST,DELETE and PATCH */
/**
 * This method is used to making http request for FormData
 * @param {string} url - form full url including path parameters if applicable
 * @param {object} headerOptions - pass header values
 * @param {string} HttpMethod - GET, POST , PUT, PATCH , DELETE etc , GET is default
 * @param {Map<string, any>} formDataMap - json string
 * @returns {Promise<object>}
 */
async function makeHttpRequestWithFormData(url, headerOptions, HttpMethod, formDataMap) {
    if (headerOptions == null) {
        headerOptions = { Accept: "application/json" };
    }
    if (HttpMethod == null) {
        HttpMethod = "GET"; //default GET method
    }
    for (const [key, value] of formDataMap) {
        form.append(key, value);
    }
    try {
        responseData = await got(url, {
            headers: headerOptions,
            body: form,
            method: HttpMethod,
            retry: 1
        }); // Note: Using "any" for the type, since got has a number of variants for the options parameter.
        // It would be better to replace the "any" with a more specific type, if that can be determined.
    }
    catch (error) {
        const customError = JSON.parse(JSON.stringify(error));
        const message = {
            "message": error.message,
            "name": customError.name,
            "code": customError.code,
            "host": customError.host,
            "url": customError.url,
            "path": customError.path
        };
        throw JSON.stringify(message);
    }
    return responseData;
}
exports.makeHttpRequestWithFormData = makeHttpRequestWithFormData;
/**
 * This method is used to making http request
 * @param {string} url - form full url including path parameters if applicable
 * @param {string} _localHost - proxy server
 * @param {number} _port - port number
 * @param {object} headerOptions - pass header values
 * @param {string} HttpMethod - GET, POST , PUT, PATCH , DELETE etc , GET is default
 * @param {string} inputBody - json string
 * @param {boolean} formFlag - default false
 */
async function makeHttpRequestWithProxy(url, _localHost, _port, _headerOptions, HttpMethod, inputBody, formFlag) {
    if (_headerOptions == null) {
        _headerOptions = { Accept: "application/json" };
    }
    if (inputBody == null) {
        inputBody = "";
    }
    else if (formFlag) {
        inputBody = JSON.parse(inputBody);
    }
    if (HttpMethod == null) {
        HttpMethod = "GET"; //default GET method
    }
    if (formFlag == null) {
        formFlag = false;
    }
    try {
        responseData = await got(url, {
            agent: tunnel.httpOverHttp({
                proxy: {
                    host: _localHost,
                    port: _port
                }
            }),
            headers: _headerOptions,
            body: inputBody,
            form: formFlag,
            method: HttpMethod,
            retry: 1
        }); // Note: Using "any" for the type, since got has a number of variants for the options parameter.
        // It would be better to replace the "any" with a more specific type, if that can be determined.
    }
    catch (error) {
        const customError = JSON.parse(JSON.stringify(error));
        const message = {
            "message": error.message,
            "name": customError.name,
            "code": customError.code,
            "host": customError.host,
            "url": customError.url,
            "path": customError.path
        };
        throw JSON.stringify(message);
    }
    return responseData;
}
exports.makeHttpRequestWithProxy = makeHttpRequestWithProxy;
//# sourceMappingURL=serviceUtils.js.map